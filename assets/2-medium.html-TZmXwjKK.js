import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,o as a,d as n}from"./app-Du-TCu9s.js";const o={},c=n(`<h3 id="使用过-context-吗-context-有哪些使用场景" tabindex="-1"><a class="header-anchor" href="#使用过-context-吗-context-有哪些使用场景"><span>使用过 <code>context</code> 吗？ <code>context</code> 有哪些使用场景？</span></a></h3><details class="hint-container details"><summary>答案</summary><table><thead><tr><th>场景</th><th>介绍</th></tr></thead><tbody><tr><td>超时处理</td><td>通过使用 <code>context</code> 可以方便地设置超时时间，在超时后自动终止协程</td></tr><tr><td>终止协程</td><td>通过使用 <code>cancel()</code> 方法，协程可以很方便地终止</td></tr><tr><td>传递数据</td><td>我们可以将数据写入 <code>context</code>, 在不同协程间传递数据</td></tr></tbody></table></details><h3 id="channel-是线程安全的吗" tabindex="-1"><a class="header-anchor" href="#channel-是线程安全的吗"><span>channel 是线程安全的吗？</span></a></h3><details class="hint-container details"><summary>答案</summary><p><code>channel</code> 是线程安全的，原因是 channel 内部实现了锁的机制，</p></details><h2 id="map-相关" tabindex="-1"><a class="header-anchor" href="#map-相关"><span>Map 相关</span></a></h2><h3 id="map-使用-range-遍历时是有序还是无序的" tabindex="-1"><a class="header-anchor" href="#map-使用-range-遍历时是有序还是无序的"><span>Map 使用 range 遍历时是有序还是无序的？</span></a></h3><details class="hint-container details"><summary>答案</summary><p><strong>无序的</strong></p><p>Map 在内部使用哈希算法放置元素，在自动扩容时又会重新计算哈希值，因此元素的地址会不断变化，官方为了避免用户认为 Map 元素排列是有序的，直接采用随机顺序返回，所以遍历是无序的。</p></details><h3 id="map-并发安全吗" tabindex="-1"><a class="header-anchor" href="#map-并发安全吗"><span>Map 并发安全吗？</span></a></h3><details class="hint-container details"><summary>答案</summary><p><strong>Map不能保证并发安全</strong></p><p>要保证并发安全，使用以下方式：</p><ul><li>手动加读写锁</li><li>使用 <code>sync.Map</code></li></ul></details><h3 id="map-的-key-删除后-key-的内存会被释放吗" tabindex="-1"><a class="header-anchor" href="#map-的-key-删除后-key-的内存会被释放吗"><span>Map 的 key 删除后 key 的内存会被释放吗？</span></a></h3><details class="hint-container details"><summary>答案</summary><p>若 map 的 value 为</p><ul><li><strong>值类型</strong> (<code>int</code> <code>uint</code> <code>float32</code> <code>string</code> <code>struct{}</code>...), 则 key 被删除后 value 不会被内存回收</li><li><strong>引用类型</strong> (<code>map</code> <code>slices</code> <code>chan</code> ...), 则 key 被删除后 value 会被内存回收</li></ul><blockquote><p>如果我们想强制回收，如何操作？</p></blockquote><ul><li>将 map 设置为 nil</li><li>将 map 需要保留的值放置到一个新的 map 并赋值给当前的 map</li></ul><div class="hint-container tip"><p class="hint-container-title">会员专属</p><p><a href="https://articles.zsxq.com/id_4w1a11i6xrw0.html" target="_blank" rel="noopener noreferrer">代码实战解析</a></p></div></details><h3 id="map-产生的-panic-异常能被-recover-吗" tabindex="-1"><a class="header-anchor" href="#map-产生的-panic-异常能被-recover-吗"><span>Map 产生的 panic 异常能被 recover 吗？</span></a></h3><details class="hint-container details"><summary>答案</summary><p>Map 由于并发读写导致的 panic 是不能被 recover 的，因为 Map 的异常使用 <code>runtime.throw()</code> 抛出，这类异常不能被 recover。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">if</span> h<span class="token punctuation">.</span>flags<span class="token operator">&amp;</span>hashWriting <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
  <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&quot;concurrent map read and map write&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>`,13),i=[c];function s(r,l){return a(),t("div",null,i)}const m=e(o,[["render",s],["__file","2-medium.html.vue"]]),h=JSON.parse('{"path":"/guide/interview/golang/basic/2-medium.html","title":"进阶","lang":"zh-CN","frontmatter":{"order":2,"title":"进阶","icon":"line-md:sunny-filled-loop-to-moon-filled-loop-transition","head":[["meta",{"name":"keywords","content":"golang, 进阶, 协程, channel, context, 面试题, 面试"}],["link",{"rel":"alternate","hreflang":"en-us","href":"https://goguide.ryansu.tech/en/guide/interview/golang/basic/2-medium.html"}],["meta",{"property":"og:url","content":"https://goguide.ryansu.tech/guide/interview/golang/basic/2-medium.html"}],["meta",{"property":"og:site_name","content":"Go 面试宝典"}],["meta",{"property":"og:title","content":"进阶"}],["meta",{"property":"og:description","content":"使用过 context 吗？ context 有哪些使用场景？ 答案 channel 是线程安全的吗？ 答案 channel 是线程安全的，原因是 channel 内部实现了锁的机制， Map 相关 Map 使用 range 遍历时是有序还是无序的？ 答案 无序的 Map 在内部使用哈希算法放置元素，在自动扩容时又会重新计算哈希值，因此元素的地址会不断..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:locale:alternate","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-05-22T00:56:38.000Z"}],["meta",{"property":"article:author","content":"Go Guide"}],["meta",{"property":"article:modified_time","content":"2024-05-22T00:56:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"进阶\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-22T00:56:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Go Guide\\",\\"url\\":\\"https://github.com/suyuan32\\"}]}"]],"description":"使用过 context 吗？ context 有哪些使用场景？ 答案 channel 是线程安全的吗？ 答案 channel 是线程安全的，原因是 channel 内部实现了锁的机制， Map 相关 Map 使用 range 遍历时是有序还是无序的？ 答案 无序的 Map 在内部使用哈希算法放置元素，在自动扩容时又会重新计算哈希值，因此元素的地址会不断..."},"headers":[{"level":3,"title":"使用过 context 吗？ context 有哪些使用场景？","slug":"使用过-context-吗-context-有哪些使用场景","link":"#使用过-context-吗-context-有哪些使用场景","children":[]},{"level":3,"title":"channel 是线程安全的吗？","slug":"channel-是线程安全的吗","link":"#channel-是线程安全的吗","children":[]},{"level":2,"title":"Map 相关","slug":"map-相关","link":"#map-相关","children":[{"level":3,"title":"Map 使用 range 遍历时是有序还是无序的？","slug":"map-使用-range-遍历时是有序还是无序的","link":"#map-使用-range-遍历时是有序还是无序的","children":[]},{"level":3,"title":"Map 并发安全吗？","slug":"map-并发安全吗","link":"#map-并发安全吗","children":[]},{"level":3,"title":"Map 的 key 删除后 key 的内存会被释放吗？","slug":"map-的-key-删除后-key-的内存会被释放吗","link":"#map-的-key-删除后-key-的内存会被释放吗","children":[]},{"level":3,"title":"Map 产生的 panic 异常能被 recover 吗？","slug":"map-产生的-panic-异常能被-recover-吗","link":"#map-产生的-panic-异常能被-recover-吗","children":[]}]}],"git":{"createdTime":1705721989000,"updatedTime":1716339398000,"contributors":[{"name":"Ryan Su","email":"yuansu.china.work@gmail.com","commits":7}]},"readingTime":{"minutes":1.62,"words":486},"filePathRelative":"guide/interview/golang/basic/2-medium.md","localizedDate":"2024年1月20日","autoDesc":true,"excerpt":"<h3>使用过 <code>context</code> 吗？ <code>context</code> 有哪些使用场景？</h3>\\n<details class=\\"hint-container details\\"><summary>答案</summary>\\n<table>\\n<thead>\\n<tr>\\n<th>场景</th>\\n<th>介绍</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>超时处理</td>\\n<td>通过使用 <code>context</code> 可以方便地设置超时时间，在超时后自动终止协程</td>\\n</tr>\\n<tr>\\n<td>终止协程</td>\\n<td>通过使用 <code>cancel()</code> 方法，协程可以很方便地终止</td>\\n</tr>\\n<tr>\\n<td>传递数据</td>\\n<td>我们可以将数据写入 <code>context</code>, 在不同协程间传递数据</td>\\n</tr>\\n</tbody>\\n</table>\\n</details>"}');export{m as comp,h as data};
