import{_ as a,a as c,b as o,c as r,d as s}from"./tcp-congestion-control-I9aAiC2N.js";import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o as h,c as g,a as t,e,f as i,b as d}from"./app-C5O2l-lo.js";const u="/assets/image/article/network/tcp.png",m="/assets/image/article/network/tcp_state.png",C="/assets/image/article/network/tcp-send-window.png",T="/assets/image/article/network/tcp-receive-window.png",P="/assets/image/article/network/udp.png",f={},y=d('<h3 id="tcp" tabindex="-1"><a class="header-anchor" href="#tcp"><span>TCP</span></a></h3><p>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p><h4 id="tcp-头部结构" tabindex="-1"><a class="header-anchor" href="#tcp-头部结构"><span>TCP 头部结构</span></a></h4><figure><img src="'+u+'" alt="tcp 头部" tabindex="0" loading="lazy"><figcaption>tcp 头部</figcaption></figure><table><thead><tr><th>TCP头部字段</th><th>描述</th></tr></thead><tbody><tr><td>源端口</td><td>发送方的端口号，范围(0~65535)</td></tr><tr><td>目标端口</td><td>接收方的端口号，范围(0~65535)</td></tr><tr><td>序列号</td><td>如果TCP数据过大（大于IP数据包的允许程度），则需要进行分段。这个序列号记录每个数据包的序列号，使接收端可以重新组合TCP数据。序列号字段的值是本报文段发送的数据的第一个字节的序列号。简称为<code>seq</code></td></tr><tr><td>确认号</td><td>为了确认接收端确实收到了发送端发送的数据包数据，当发送端收到这个确认码时，就可以确定之前传递的数据包已经被正确接收。这个确认号是期望收到对方下一个报文段的数据的第一个字节的序列号。简称<code>ack</code></td></tr><tr><td>头部长度</td><td>表示TCP头部的长度，范围(0~15)，单位32位，例如值为5时，表示头部长度是20字节（160位），如果选项字段为空，则TCP头部长度为20字节，即值为5</td></tr><tr><td>URG</td><td><code>URG=1</code>表示存在紧急数据，紧急数据的最后一个字节由紧急数据指针指出，一般使用较少</td></tr><tr><td>ACK</td><td><code>ACK=1</code>表示确认号字段中的值是有效的，为0表示无效</td></tr><tr><td>PSH</td><td><code>URG=1</code>表示紧急指针字段有效，代表该数据包为紧急数据包。它告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据）</td></tr><tr><td>RST</td><td><code>RSP=1</code>表示重建连接，如果接收到RST位时，通常发生了某些错误</td></tr><tr><td>SYN</td><td><code>SYN=1</code>表示这是一个连接请求或连接接受报文，一般用于握手阶段</td></tr><tr><td>FIN</td><td><code>FIN=1</code>表示此报文段的发送端的数据已发送完毕，并要求释放运输连接</td></tr><tr><td>接收窗口</td><td>用于流量控制，指示接收方愿意接收的字节数量，范围<code>0~65535</code>字节</td></tr><tr><td>校验和</td><td>校验和覆盖了整个TCP报文段，即TCP头部和TCP数据，这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证</td></tr><tr><td>紧急数据指针</td><td>当<code>URG=1</code>时有效，是一个正的偏移量，和序列号中的值相加表示紧急数据最后一个字节的序列号</td></tr><tr><td>选项</td><td>用于发送方和接收方协商最大报文长度（MSS）时（只存在于SYN报文）或在高速网络环境下用作窗口调节因子时使用，还可以存放时间戳数据</td></tr></tbody></table><h4 id="tcp-状态机" tabindex="-1"><a class="header-anchor" href="#tcp-状态机"><span>TCP 状态机</span></a></h4><figure><img src="'+m+'" alt="TCP Stateful" tabindex="0" loading="lazy"><figcaption>TCP Stateful</figcaption></figure><h4 id="tcp-三次握手-四次挥手" tabindex="-1"><a class="header-anchor" href="#tcp-三次握手-四次挥手"><span>TCP 三次握手/四次挥手</span></a></h4><figure><img src="'+a+'" alt="TCP Connection" tabindex="0" loading="lazy"><figcaption>TCP Connection</figcaption></figure><div class="hint-container tip"><p class="hint-container-title">三次握手过程</p><ol><li>客户端发送<code>SYN=1</code>，并指明客户端的初始序列号<code>ISN</code>，即<code>x</code>.</li><li>服务端发送自己的<code>SYN</code>段作为应答，同样指明自己的<code>ISN</code> 即 <code>y</code>。为了确认客户端的<code>SYN</code>，将<code>x+1</code>作为<code>ACK</code>数值。这样，每发送一个<code>SYN</code>，序列号就会加1. 如果有丢失的情况，则会重传。</li><li>为了确认服务器端的<code>SYN</code>，客户端将<code>y+1</code>作为返回的<code>ACK</code>数值。</li></ol></div><div class="hint-container tip"><p class="hint-container-title">TCP 四次挥手</p><ol><li>客户端发送<code>FIN=1</code>，并包含一个自己当前的序列号<code>x+2</code>。 同时还包含一个<code>ACK=y+1</code>表示确认对方最近一次发过来的数据。</li><li>服务端将<code>x+2</code>值加1作为<code>ACK</code>序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</li><li>服务端发起自己的<code>FIN=1</code>，<code>seq=y+1</code> 。</li><li>客户端确认, 向服务器发送 <code>ACK=y+2</code> 。</li></ol></div><div class="hint-container warning"><p class="hint-container-title">为什么要三次握手？作用是什么？</p><details class="hint-container details"><summary>详情</summary><p>TCP 建立连接的过程就是同步序列号的过程，SYN (Synchronize Sequence Numbers)就是同步序列号。因此，三次握手的目的就是使客户端(Client)和服务端(Service)获取到对方的序列号。</p></details></div><div class="hint-container warning"><p class="hint-container-title">为什么要四次挥手？作用是什么？</p><details class="hint-container details"><summary>详情</summary><p>之所以需要四次挥手，是因为 tcp 是<strong>全双工</strong>协议，即客户端和服务端都可以主动发送消息，因此需要两端分别在传输完成后发送断开连接的指令，需要分别发送 <code>FIN=1</code> 指令断开，通过 <code>ACK</code> 判断是否发送成功。</p></details></div><div class="hint-container caution"><p class="hint-container-title">如果连接时 SYN 超时会发生什么？</p><details class="hint-container details"><summary>详情</summary><p>假如客户端发送 <code>SYN</code> 指令，在服务器返回 <code>SYN</code> 指令之前掉线了，服务器会尝试重发 <code>SYN-ACK</code> 指令，linux 下默认重试 5 次，间隔时间从 1s 开始翻倍增长，即 <code>1s, 2s, 4s, 8s, 16s</code>, 因此超时时间为 <code>1s + 2s + 4s+ 8s+ 16s + 32s = 63s</code>。在超时之后 TCP 才会断开连接。</p></details></div><h4 id="tcp-如何保证传输的可靠性" tabindex="-1"><a class="header-anchor" href="#tcp-如何保证传输的可靠性"><span>TCP 如何保证传输的可靠性？</span></a></h4><div class="hint-container tip"><p class="hint-container-title">TCP 通过以下几个特性保证数据传输的可靠性</p><ul><li>序列号和确认应答</li><li>超时重传</li><li>流量控制</li><li>拥塞控制</li><li>校验和</li></ul></div><h5 id="序列号和确认应答信号" tabindex="-1"><a class="header-anchor" href="#序列号和确认应答信号"><span><strong>序列号和确认应答信号</strong></span></a></h5><p>TCP 通过序列号可以对数据包进行排序和去重，同时通过 ACK 应答机制确保数据包成功送达，保证了数据的完整性。</p><h5 id="超时重传" tabindex="-1"><a class="header-anchor" href="#超时重传"><span><strong>超时重传</strong></span></a></h5><p>TCP 通过超时重传机制可以在数据包丢失或者延迟时，重新发送数据包直到收到 ACK 应答。</p><div class="hint-container warning"><p class="hint-container-title">什么是RTT？什么是RTO？</p><details class="hint-container details"><summary>详情</summary><p>RTT代表往返时间（Round Trip Time），是指数据从发送方传输到接收方并返回所需的时间。RTT用于衡量网络延迟，即数据在传输过程中经过的总时间。</p><p>RTO代表重传超时时间（Retransmission Timeout），是指在网络通信中，发送方发送数据后等待确认（ACK）的时间。如果发送方在RTO时间内未收到确认，它会假设数据丢失，并重新发送该数据。</p><p>RTO的计算通常基于RTT的测量。发送方根据前一次的RTT来估计下一次发送数据的RTO。一般情况下，RTO的值会比RTT大一些，以确保在网络延迟较高或不稳定的情况下也能够成功重传数据。</p><p>RTO的计算方法可以根据具体的网络协议或实现而有所不同，但其目的是为了确保数据的可靠传输，以应对网络中的丢包、延迟和拥塞等问题。</p></details></div><div class="hint-container warning"><p class="hint-container-title">RTO 长短对重传有什么影响？</p><details class="hint-container details"><summary>详情</summary><p>若 RTO 过长则重传时间会大大延长，降低传输效率。若 RTO 过短则可能会导致频繁重传，加剧网络的拥堵，进一步触发更多的重传。</p></details></div>',22),_={class:"hint-container tip"},w=t("p",{class:"hint-container-title"},"常见的重传机制",-1),S={class:"hint-container details"},b=d('<summary>详情</summary><ul><li>超时重传</li></ul><figure><img src="'+c+'" alt="timeout retransmission" tabindex="0" loading="lazy"><figcaption>timeout retransmission</figcaption></figure><p>超时重传有两种情况，发送的数据包丢失导致的超时，和返回的 ACK 数据包丢失导致的超时。超时重传机制下，在每次发送数据包的时候都会启动一个定时器，如果定时器到期则会触发重传。若重传失败，则下一次超时时间为当前值的两倍。<mark>超时重传的缺点是周期较长，可能会降低效率。</mark></p><ul><li>快速重传</li></ul><figure><img src="'+o+'" alt="tcp" tabindex="0" loading="lazy"><figcaption>tcp</figcaption></figure><p>在快速重传机制下，在数据包丢失后，接收端每接收一个失序的数据包就立即返回重复的确认报文段，告知发送端缺少的报文段。当发送方收到三个重复的确认报文段后，会立即重传缺失的报文段。</p><p><mark>在快速重传的机制下，我们可以看到 <code>3,4,5</code> 的报文段返回的都是 <code>ACK=2</code>, 因此还需要重传 <code>3,4,5</code> 报文段。有没有方法可以不需要重传 <code>3,4,5</code> 报文段？</mark></p><ul><li>SACK (Selective Acknowledgment, 选择性确认)</li></ul><figure><img src="'+r+'" alt="SACK" tabindex="0" loading="lazy"><figcaption>SACK</figcaption></figure>',10),v={href:"https://www.ietf.org/rfc/rfc2883.txt",target:"_blank",rel:"noopener noreferrer"},k=t("ul",null,[t("li",null,"D-SACK (Duplicate SACK, 重复选择性确认)")],-1),x={href:"https://datatracker.ietf.org/doc/html/rfc2018",target:"_blank",rel:"noopener noreferrer"},R=d('<h5 id="流量控制" tabindex="-1"><a class="header-anchor" href="#流量控制"><span><strong>流量控制</strong></span></a></h5><p>TCP 使用滑动窗口来控制流量，使得发送端可以根据接收端的接收能力控制发送数据的速度。</p><p><img src="'+C+'" alt="发送窗口(窗口大小为 7)" loading="lazy"><img src="'+T+'" alt="接收窗口(窗口大小为 7)" loading="lazy"></p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>接收端在应答 <code>ACK</code> 的时候会将当前可用的窗口大小写入 tcp 头部，发送端根据窗口大小调整发送速率。</p></div><h5 id="拥塞控制" tabindex="-1"><a class="header-anchor" href="#拥塞控制"><span><strong>拥塞控制</strong></span></a></h5><div class="hint-container tip"><p class="hint-container-title">算法</p><ul><li>慢开始</li><li>拥塞避免</li><li>快重传</li><li>快恢复</li></ul></div><figure><img src="'+s+'" alt="拥塞控制" tabindex="0" loading="lazy"><figcaption>拥塞控制</figcaption></figure><div class="hint-container info"><p class="hint-container-title">相关名词</p><ul><li>cwnd - 拥塞窗口</li><li>ssthresh - 慢开始门限</li></ul></div><div class="hint-container important"><p class="hint-container-title">重要</p><ul><li><p><code>cwnd &lt; ssthresh</code>，使用慢开始算法。</p></li><li><p><code>cwnd &gt; ssthresh</code>，使用拥塞避免算法。</p></li><li><p><code>cwnd = ssthresh</code>，使用慢开始与拥塞避免算法任意一个。</p></li></ul></div><h6 id="慢开始" tabindex="-1"><a class="header-anchor" href="#慢开始"><span><strong>慢开始</strong></span></a></h6><p>在慢开始阶段， <code>cwnd</code> 初始值为 <code>1</code>, 每经过一个传播轮次，<code>cwnd</code> 都会翻倍，直到达到 <code>ssthresh</code> 。</p><h6 id="拥塞避免" tabindex="-1"><a class="header-anchor" href="#拥塞避免"><span><strong>拥塞避免</strong></span></a></h6><p>当 <code>cwnd</code> 达到 <code>ssthresh</code> ，则会执行拥塞避免算法，此时 <code>cwnd</code> 的增长从翻倍增长变为每经过一个传播轮次就加 <code>1</code> 。若发送方检测到网络拥塞（即发送的消息没得到及时的回应），就会将 <code>ssthresh</code> 设置为发生网络拥塞时的 <code>cwnd</code> 值的一半，同时 <code>cwnd</code> 的值将会重置为 <code>1</code> ，重新执行慢开始。</p><h6 id="快重传和快恢复" tabindex="-1"><a class="header-anchor" href="#快重传和快恢复"><span><strong>快重传和快恢复</strong></span></a></h6><p>快重传在前面已介绍过，即如果连续收到三个重复的确认就会立即发送尚未接收到的报文段。快恢复算法需要配合快重传算法使用。图中的 5 号为快恢复阶段。</p><div class="hint-container info"><p class="hint-container-title">快恢复算法</p><ul><li>当发送端连续收到三个重复的确认时，将 <code>ssthresh</code> 减半。</li><li>将 <code>cwnd</code> 设置为 <code>ssthresh</code> 的大小</li></ul></div><h5 id="校验和" tabindex="-1"><a class="header-anchor" href="#校验和"><span><strong>校验和</strong></span></a></h5><p>TCP 还会对数据计算校验和，确保数据在传输过程中未丢失或出现错误。</p><h3 id="udp" tabindex="-1"><a class="header-anchor" href="#udp"><span>UDP</span></a></h3><p>UDP，全称用户数据报协议（User Datagram Protocol），是OSI（开放系统互联）参考模型中的一种无连接的传输层协议。它提供面向事务的简单不可靠信息传送服务，其正式规范是 <code>IETF RFC 768</code>。</p><h4 id="特点" tabindex="-1"><a class="header-anchor" href="#特点"><span>特点</span></a></h4><ul><li>无连接：UDP在传输数据前不需要在客户和服务器之间建立一个连接。</li><li>速度快：由于UDP不需要进行握手或检查数据是否正确到达，所以它能够比TCP更快地传输数据。</li><li>不可靠性：当报文发送之后，是无法得知其是否安全完整到达的。如果UDP数据报在传输过程中丢失，它不会重新发送。</li><li>应用广泛：UDP用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用UDP协议。例如，许多互联网电话服务使用的IP语音 (VoIP) 通常是使用UDP发送的。</li></ul><h4 id="结构" tabindex="-1"><a class="header-anchor" href="#结构"><span>结构</span></a></h4><figure><img src="'+P+'" alt="udp" tabindex="0" loading="lazy"><figcaption>udp</figcaption></figure><table><thead><tr><th>字段</th><th>大小</th><th>描述</th></tr></thead><tbody><tr><td>源端口</td><td>16位</td><td>源端口号。若全为 0 则意味着不允许回信</td></tr><tr><td>目的端口</td><td>16位</td><td>目标端口号</td></tr><tr><td>长度</td><td>16位</td><td>UDP用户数据报的长度,其最小值是8(仅有首部)</td></tr><tr><td>检验和</td><td>16位</td><td>检测数据在传输过程中是否丢失或修改</td></tr></tbody></table><h4 id="广播类型" tabindex="-1"><a class="header-anchor" href="#广播类型"><span>广播类型</span></a></h4><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>单播</td><td>用于两个主机之间端对端的通信。即一对一（客户端与服务器端点到点连接）</td></tr><tr><td>广播</td><td>用于一个主机对整个局域网上所有主机通信。即一对所有。广播禁止在Internet宽带网上传输（广播风暴）</td></tr><tr><td>组播（多播）</td><td>对一组特定的主机进行通信，而不是整个局域网上的所有主机。即一对一组</td></tr></tbody></table><div class="hint-container warning"><p class="hint-container-title">注意</p><ul><li>TCP 只支持一对一</li><li>UDP 多播较为常用，广播仅用于局域网</li></ul></div><div class="hint-container info"><p class="hint-container-title">TCP 和 UDP 区别</p><table><thead><tr><th>特性</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>可靠传输</td><td>是</td><td>否</td></tr><tr><td>连接</td><td>面向连接</td><td>无连接</td></tr><tr><td>数据有序性</td><td>有</td><td>不保证</td></tr><tr><td>数据边界</td><td>不保存</td><td>保留</td></tr><tr><td>传输速度</td><td>相对慢</td><td>快</td></tr><tr><td>流量控制和拥塞控制</td><td>有</td><td>没有</td></tr><tr><td>协议类型</td><td>重量级</td><td>轻量级</td></tr><tr><td>首部长度</td><td>20字节</td><td>8字节</td></tr></tbody></table></div>',29);function N(A,K){const n=p("ExternalLinkIcon");return h(),g("div",null,[y,t("div",_,[w,t("details",S,[b,t("p",null,[e("SACK 方法 ("),t("a",v,[e("RFC 2018"),i(n)]),e(") 在 tcp 的 option 字段添加了缓冲区，用于记录已传输的数据包，这样发送方可以看到未成功传输的数据包，使得发送方可以仅传输缺失的数据包而不需要额外重传其他数据包。")]),k,t("p",null,[e("D-SACK ("),t("a",x,[e("RFC 2883"),i(n)]),e(") 主要解决了 ACK 丢失的问题， D-SACK 使用 SACK 第一个段作为标志位，用于标记已经 ACK 的数据包。 当接收端接收到重复的报文段时会将该报文段写入 D-SACK 的标志位，告诉发送方已接收到报文段， ACK 可能已丢失。")])])]),R])}const Y=l(f,[["render",N],["__file","3-tcp-udp.html.vue"]]),z=JSON.parse('{"path":"/guide/concepts/network/3-tcp-udp.html","title":"TCP/UDP","lang":"zh-CN","frontmatter":{"order":3,"title":"TCP/UDP","description":"TCP 传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。 TCP 头部结构 tcp 头部tcp 头部 TCP 状态机 TCP StatefulTCP Stateful TCP 三次握手/四次挥手 TCP ConnectionTCP Connection 三次握手过程...","head":[["link",{"rel":"alternate","hreflang":"en-us","href":"https://goguide.ryansu.tech/en/guide/concepts/network/3-tcp-udp.html"}],["meta",{"property":"og:url","content":"https://goguide.ryansu.tech/guide/concepts/network/3-tcp-udp.html"}],["meta",{"property":"og:site_name","content":"Go 面试宝典"}],["meta",{"property":"og:title","content":"TCP/UDP"}],["meta",{"property":"og:description","content":"TCP 传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。 TCP 头部结构 tcp 头部tcp 头部 TCP 状态机 TCP StatefulTCP Stateful TCP 三次握手/四次挥手 TCP ConnectionTCP Connection 三次握手过程..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://goguide.ryansu.tech/assets/image/article/network/tcp.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:locale:alternate","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-02-17T03:20:37.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"TCP/UDP"}],["meta",{"property":"article:author","content":"Go Guide"}],["meta",{"property":"article:modified_time","content":"2024-02-17T03:20:37.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"TCP/UDP\\",\\"image\\":[\\"https://goguide.ryansu.tech/assets/image/article/network/tcp.png\\",\\"https://goguide.ryansu.tech/assets/image/article/network/tcp_state.png\\",\\"https://goguide.ryansu.tech/assets/image/article/network/tcp-connect.png\\",\\"https://goguide.ryansu.tech/assets/image/article/network/timeout-retransmission.png\\",\\"https://goguide.ryansu.tech/assets/image/article/network/tcp-3-retry-new.png\\",\\"https://goguide.ryansu.tech/assets/image/article/network/sack.png\\",\\"https://goguide.ryansu.tech/assets/image/article/network/tcp-send-window.png\\",\\"https://goguide.ryansu.tech/assets/image/article/network/tcp-receive-window.png\\",\\"https://goguide.ryansu.tech/assets/image/article/network/tcp-congestion-control.png\\",\\"https://goguide.ryansu.tech/assets/image/article/network/udp.png\\"],\\"dateModified\\":\\"2024-02-17T03:20:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Go Guide\\",\\"url\\":\\"https://github.com/suyuan32\\"}]}"]]},"headers":[{"level":3,"title":"TCP","slug":"tcp","link":"#tcp","children":[{"level":4,"title":"TCP 头部结构","slug":"tcp-头部结构","link":"#tcp-头部结构","children":[]},{"level":4,"title":"TCP 状态机","slug":"tcp-状态机","link":"#tcp-状态机","children":[]},{"level":4,"title":"TCP 三次握手/四次挥手","slug":"tcp-三次握手-四次挥手","link":"#tcp-三次握手-四次挥手","children":[]},{"level":4,"title":"TCP 如何保证传输的可靠性？","slug":"tcp-如何保证传输的可靠性","link":"#tcp-如何保证传输的可靠性","children":[]}]},{"level":3,"title":"UDP","slug":"udp","link":"#udp","children":[{"level":4,"title":"特点","slug":"特点","link":"#特点","children":[]},{"level":4,"title":"结构","slug":"结构","link":"#结构","children":[]},{"level":4,"title":"广播类型","slug":"广播类型","link":"#广播类型","children":[]}]}],"git":{"createdTime":1708140037000,"updatedTime":1708140037000,"contributors":[{"name":"Ryan Su","email":"yuansu.china.work@gmail.com","commits":1}]},"readingTime":{"minutes":10.96,"words":3287},"filePathRelative":"guide/concepts/network/3-tcp-udp.md","localizedDate":"2024年2月17日","autoDesc":true,"excerpt":"<h3>TCP</h3>\\n<p>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p>\\n<h4>TCP 头部结构</h4>\\n<figure><img src=\\"/assets/image/article/network/tcp.png\\" alt=\\"tcp 头部\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>tcp 头部</figcaption></figure>\\n<table>\\n<thead>\\n<tr>\\n<th>TCP头部字段</th>\\n<th>描述</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>源端口</td>\\n<td>发送方的端口号，范围(0~65535)</td>\\n</tr>\\n<tr>\\n<td>目标端口</td>\\n<td>接收方的端口号，范围(0~65535)</td>\\n</tr>\\n<tr>\\n<td>序列号</td>\\n<td>如果TCP数据过大（大于IP数据包的允许程度），则需要进行分段。这个序列号记录每个数据包的序列号，使接收端可以重新组合TCP数据。序列号字段的值是本报文段发送的数据的第一个字节的序列号。简称为<code>seq</code></td>\\n</tr>\\n<tr>\\n<td>确认号</td>\\n<td>为了确认接收端确实收到了发送端发送的数据包数据，当发送端收到这个确认码时，就可以确定之前传递的数据包已经被正确接收。这个确认号是期望收到对方下一个报文段的数据的第一个字节的序列号。简称<code>ack</code></td>\\n</tr>\\n<tr>\\n<td>头部长度</td>\\n<td>表示TCP头部的长度，范围(0~15)，单位32位，例如值为5时，表示头部长度是20字节（160位），如果选项字段为空，则TCP头部长度为20字节，即值为5</td>\\n</tr>\\n<tr>\\n<td>URG</td>\\n<td><code>URG=1</code>表示存在紧急数据，紧急数据的最后一个字节由紧急数据指针指出，一般使用较少</td>\\n</tr>\\n<tr>\\n<td>ACK</td>\\n<td><code>ACK=1</code>表示确认号字段中的值是有效的，为0表示无效</td>\\n</tr>\\n<tr>\\n<td>PSH</td>\\n<td><code>URG=1</code>表示紧急指针字段有效，代表该数据包为紧急数据包。它告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据）</td>\\n</tr>\\n<tr>\\n<td>RST</td>\\n<td><code>RSP=1</code>表示重建连接，如果接收到RST位时，通常发生了某些错误</td>\\n</tr>\\n<tr>\\n<td>SYN</td>\\n<td><code>SYN=1</code>表示这是一个连接请求或连接接受报文，一般用于握手阶段</td>\\n</tr>\\n<tr>\\n<td>FIN</td>\\n<td><code>FIN=1</code>表示此报文段的发送端的数据已发送完毕，并要求释放运输连接</td>\\n</tr>\\n<tr>\\n<td>接收窗口</td>\\n<td>用于流量控制，指示接收方愿意接收的字节数量，范围<code>0~65535</code>字节</td>\\n</tr>\\n<tr>\\n<td>校验和</td>\\n<td>校验和覆盖了整个TCP报文段，即TCP头部和TCP数据，这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证</td>\\n</tr>\\n<tr>\\n<td>紧急数据指针</td>\\n<td>当<code>URG=1</code>时有效，是一个正的偏移量，和序列号中的值相加表示紧急数据最后一个字节的序列号</td>\\n</tr>\\n<tr>\\n<td>选项</td>\\n<td>用于发送方和接收方协商最大报文长度（MSS）时（只存在于SYN报文）或在高速网络环境下用作窗口调节因子时使用，还可以存放时间戳数据</td>\\n</tr>\\n</tbody>\\n</table>"}');export{Y as comp,z as data};
