---
order: 2
title: "TCP/UDP"
---

### TCP

传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。

#### TCP 头部结构

![tcp 头部](/assets/image/article/network/tcp.png)

| TCP头部字段  | 描述                                                                                                                                                                                          |
| ------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 源端口       | 发送方的端口号，范围(0~65535)                                                                                                                                                                 |
| 目标端口     | 接收方的端口号，范围(0~65535)                                                                                                                                                                 |
| 序列号       | 如果TCP数据过大（大于IP数据包的允许程度），则需要进行分段。这个序列号记录每个数据包的序列号，使接收端可以重新组合TCP数据。序列号字段的值是本报文段发送的数据的第一个字节的序列号。简称为`seq` |
| 确认号       | 为了确认接收端确实收到了发送端发送的数据包数据，当发送端收到这个确认码时，就可以确定之前传递的数据包已经被正确接收。这个确认号是期望收到对方下一个报文段的数据的第一个字节的序列号。简称`ack` |
| 头部长度     | 表示TCP头部的长度，范围(0~15)，单位32位，例如值为5时，表示头部长度是20字节（160位），如果选项字段为空，则TCP头部长度为20字节，即值为5                                                         |
| URG          | `URG=1`表示存在紧急数据，紧急数据的最后一个字节由紧急数据指针指出，一般使用较少                                                                                                               |
| ACK          | `ACK=1`表示确认号字段中的值是有效的，为0表示无效                                                                                                                                              |
| PSH          | `URG=1`表示紧急指针字段有效，代表该数据包为紧急数据包。它告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据）                                                                     |
| RST          | `RSP=1`表示重建连接，如果接收到RST位时，通常发生了某些错误                                                                                                                                    |
| SYN          | `SYN=1`表示这是一个连接请求或连接接受报文，一般用于握手阶段                                                                                                                                   |
| FIN          | `FIN=1`表示此报文段的发送端的数据已发送完毕，并要求释放运输连接                                                                                                                               |
| 接收窗口     | 用于流量控制，指示接收方愿意接收的字节数量，范围`0~65535`字节                                                                                                                                 |
| 校验和       | 校验和覆盖了整个TCP报文段，即TCP头部和TCP数据，这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证                                                                             |
| 紧急数据指针 | 当`URG=1`时有效，是一个正的偏移量，和序列号中的值相加表示紧急数据最后一个字节的序列号                                                                                                         |
| 选项         | 用于发送方和接收方协商最大报文长度（MSS）时（只存在于SYN报文）或在高速网络环境下用作窗口调节因子时使用，还可以存放时间戳数据                                                                  |

#### TCP 状态机

![TCP Stateful](/assets/image/article/network/tcp_state.png)

#### TCP 三次握手/四次挥手

![TCP Connection](/assets/image/article/network/tcp-connect.png)

::: tip 三次握手过程
1. 客户端发送`SYN=1`，并指明客户端的初始序列号`ISN`，即`x`.
2. 服务端发送自己的`SYN`段作为应答，同样指明自己的`ISN` 即 `y`。为了确认客户端的`SYN`，将`x+1`作为`ACK`数值。这样，每发送一个`SYN`，序列号就会加1. 如果有丢失的情况，则会重传。
3. 为了确认服务器端的`SYN`，客户端将`y+1`作为返回的`ACK`数值。

:::

::: tip TCP 四次挥手
1. 客户端发送`FIN=1`，并包含一个自己当前的序列号`x+2`。 同时还包含一个`ACK=y+1`表示确认对方最近一次发过来的数据。 
2. 服务端将`x+2`值加1作为`ACK`序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。 
3. 服务端发起自己的`FIN=1`，`seq=y+1` 。
4. 客户端确认, 向服务器发送 `ACK=y+2` 。
:::

::: warning 为什么要三次握手？作用是什么？

::: details
TCP 建立连接的过程就是同步序列号的过程，SYN (Synchronize Sequence Numbers)就是同步序列号。因此，三次握手的目的就是使客户端(Client)和服务端(Service)获取到对方的序列号。
:::

::: warning 为什么要四次挥手？作用是什么？

::: details
之所以需要四次挥手，是因为 tcp 是**全双工**协议，即客户端和服务端都可以主动发送消息，因此需要两端分别在传输完成后发送断开连接的指令，需要分别发送 `FIN=1` 指令断开，通过 `ACK` 判断是否发送成功。
:::

::: danger 如果连接时 SYN 超时会发生什么？

::: details
假如客户端发送 `SYN` 指令，在服务器返回 `SYN` 指令之前掉线了，服务器会尝试重发 `SYN-ACK` 指令，linux 下默认重试 5 次，间隔时间从 1s 开始翻倍增长，即 `1s, 2s, 4s, 8s, 16s`, 因此超时时间为  `1s + 2s + 4s+ 8s+ 16s + 32s = 63s`。在超时之后 TCP 才会断开连接。
:::

#### TCP 如何保证传输的可靠性？

::: tip TCP 通过以下几个特性保证数据传输的可靠性

- 序列号和确认应答
- 超时重传
- 流量控制
- 拥塞控制
- 校验和

:::

##### 序列号和确认应答信号

TCP 通过序列号可以对数据包进行排序和去重，同时通过 ACK 应答机制确保数据包成功送达，保证了数据的完整性。

#### 超时重传

TCP 通过超时重传机制可以在数据包丢失或者延迟时，重新发送数据包直到收到 ACK 应答。

::: warning 什么是RTT？什么是RTO？

::: details
RTT代表往返时间（Round Trip Time），是指数据从发送方传输到接收方并返回所需的时间。RTT用于衡量网络延迟，即数据在传输过程中经过的总时间。

RTO代表重传超时时间（Retransmission Timeout），是指在网络通信中，发送方发送数据后等待确认（ACK）的时间。如果发送方在RTO时间内未收到确认，它会假设数据丢失，并重新发送该数据。

RTO的计算通常基于RTT的测量。发送方根据前一次的RTT来估计下一次发送数据的RTO。一般情况下，RTO的值会比RTT大一些，以确保在网络延迟较高或不稳定的情况下也能够成功重传数据。

RTO的计算方法可以根据具体的网络协议或实现而有所不同，但其目的是为了确保数据的可靠传输，以应对网络中的丢包、延迟和拥塞等问题。
:::

::: warning RTO 长短对重传有什么影响？

::: details 
若 RTO 过长则重传时间会大大延长，降低传输效率。若 RTO 过短则可能会导致频繁重传，加剧网络的拥堵，进一步触发更多的重传。
:::


::: tip 常见的重传机制

::: details

- 超时重传

![timeout retransmission](/assets/image/article/network/timeout-retransmission.png)

超时重传有两种情况，发送的数据包丢失导致的超时，和返回的 ACK 数据包丢失导致的超时。超时重传机制下，在每次发送数据包的时候都会启动一个定时器，如果定时器到期则会触发重传。若重传失败，则下一次超时时间为当前值的两倍。==超时重传的缺点是周期较长，可能会降低效率。==

- 快速重传

![tcp](/assets/image/article/network/tcp-3-retry-new.png)

在快速重传机制下，在数据包丢失后，接收端每接收一个失序的数据包就立即返回重复的确认报文段，告知发送端缺少的报文段。当发送方收到三个重复的确认报文段后，会立即重传缺失的报文段。

==在快速重传的机制下，我们可以看到 `3,4,5` 的报文段返回的都是 `ACK=2`, 因此还需要重传 `3,4,5` 报文段。有没有方法可以不需要重传 `3,4,5` 报文段？==

- SACK (Selective Acknowledgment, 选择性确认)

![SACK](/assets/image/article/network/sack.png)

SACK 方法 ([RFC 2018](https://www.ietf.org/rfc/rfc2883.txt)) 在 tcp 的 option 字段添加了缓冲区，用于记录已传输的数据包，这样发送方可以看到未成功传输的数据包，使得发送方可以仅传输缺失的数据包而不需要额外重传其他数据包。

- D-SACK (Duplicate SACK, 重复选择性确认)

D-SACK ([RFC 2883](https://datatracker.ietf.org/doc/html/rfc2018)) 主要解决了 ACK 丢失的问题， D-SACK 使用 SACK 第一个段作为标志位，用于标记已经 ACK 的数据包。 当接收端接收到重复的报文段时会将该报文段写入 D-SACK 的标志位，告诉发送方已接收到报文段， ACK 可能已丢失。
:::

#### 流量控制

TCP 使用滑动窗口来控制流量，使得发送端可以根据接收端的接收能力控制发送数据的速度。

![发送窗口(窗口大小为 7)](/assets/image/article/network/tcp-send-window.png)
![接收窗口(窗口大小为 7)](/assets/image/article/network/tcp-receive-window.png)

::: warning 
接收端在应答 `ACK` 的时候会将当前可用的窗口大小写入 tcp 头部，发送端根据窗口大小调整发送速率。
:::

#### 拥塞控制

::: tip 算法
- 慢启动
- 拥塞避免
- 快重传
- 快恢复
:::

![拥塞控制](/assets/image/article/network/tcp-congestion-control.png)

### UDP

### 常见面试题

::: tip 什么是 SYN Flood 攻击？

::: details

:::

